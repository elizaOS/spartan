var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = __require("buffer").Buffer;
        }
      } catch (e) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN2.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN2.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone() {
        var r = new BN2(null);
        this.copy(r);
        return r;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN2.prototype.inspect = inspect;
        }
      } else {
        BN2.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN2.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self, num, out) {
        return bigMulTo(self, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN2.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN2(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN2.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN2(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN2._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN2(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN2(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// src/providers/positionProvider.ts
import {
  elizaLogger
} from "@elizaos/core";
import { createSolanaRpc } from "@solana/kit";

// src/utils/loadWallet.ts
import { Keypair, PublicKey } from "@solana/web3.js";
import bs58 from "bs58";
import { TEEMode } from "@elizaos/core";
async function loadWallet(runtime, requirePrivateKey = true) {
  const teeMode = runtime.getSetting("TEE_MODE") || TEEMode.OFF;
  if (teeMode !== TEEMode.OFF) {
    const walletSecretSalt = runtime.getSetting("WALLET_SECRET_SALT");
    if (!walletSecretSalt) {
      throw new Error("WALLET_SECRET_SALT required when TEE_MODE is enabled");
    }
    const deriveKeyProvider = new DeriveKeyProvider(teeMode);
    const deriveKeyResult = await deriveKeyProvider.deriveEd25519Keypair(
      "/",
      walletSecretSalt,
      runtime.agentId
    );
    return requirePrivateKey ? { signer: deriveKeyResult.keypair } : { address: deriveKeyResult.keypair.publicKey };
  }
  if (requirePrivateKey) {
    const privateKeyString = runtime.getSetting("SOLANA_PRIVATE_KEY") ?? runtime.getSetting("WALLET_PRIVATE_KEY");
    if (!privateKeyString) {
      throw new Error("Private key not found in settings");
    }
    try {
      const secretKey = bs58.decode(privateKeyString);
      return { signer: Keypair.fromSecretKey(secretKey) };
    } catch (e) {
      console.log("Error decoding base58 private key:", e);
      try {
        console.log("Try decoding base64 instead");
        const secretKey = Uint8Array.from(Buffer.from(privateKeyString, "base64"));
        return { signer: Keypair.fromSecretKey(secretKey) };
      } catch (e2) {
        console.error("Error decoding private key: ", e2);
        throw new Error("Invalid private key format");
      }
    }
  } else {
    const publicKeyString = runtime.getSetting("SOLANA_PUBLIC_KEY") ?? runtime.getSetting("WALLET_PUBLIC_KEY");
    if (!publicKeyString) {
      throw new Error("Public key not found in settings");
    }
    return { address: new PublicKey(publicKeyString) };
  }
}

// src/providers/positionProvider.ts
import { fetchPositionsForOwner } from "@orca-so/whirlpools";
import { fetchWhirlpool } from "@orca-so/whirlpools-client";
import { sqrtPriceToPrice, tickIndexToPrice } from "@orca-so/whirlpools-core";
import { fetchMint } from "@solana-program/token-2022";
var positionProvider = {
  description: "Get liquidity positions for orca whirlpools",
  dynamic: true,
  get: async (runtime, message, state) => {
    console.log("positionProvider");
    if (!state) {
      state = await runtime.composeState(message);
    } else {
      state = await runtime.composeState(message);
    }
    try {
      const { address: ownerAddress } = await loadWallet(
        runtime,
        false
      );
      const rpc = createSolanaRpc(runtime.getSetting("SOLANA_RPC_URL"));
      const positions = await fetchPositions(rpc, ownerAddress);
      const positionsString = JSON.stringify(positions);
      return positionsString;
    } catch (error) {
      elizaLogger.error("Error in wallet provider:", error);
      return null;
    }
  }
};
var fetchPositions = async (rpc, ownerAddress) => {
  try {
    const positions = await fetchPositionsForOwner(rpc, ownerAddress);
    const fetchedWhirlpools = /* @__PURE__ */ new Map();
    const fetchedMints = /* @__PURE__ */ new Map();
    const FetchedPositionsStatistics = await Promise.all(positions.map(async (position) => {
      const positionData = position.data;
      const positionMint = positionData.positionMint;
      const whirlpoolAddress = positionData.whirlpool;
      if (!fetchedWhirlpools.has(whirlpoolAddress)) {
        const whirlpool2 = await fetchWhirlpool(rpc, whirlpoolAddress);
        if (whirlpool2) {
          fetchedWhirlpools.set(whirlpoolAddress, whirlpool2.data);
        }
      }
      const whirlpool = fetchedWhirlpools.get(whirlpoolAddress);
      const { tokenMintA, tokenMintB } = whirlpool;
      if (!fetchedMints.has(tokenMintA)) {
        const mintA2 = await fetchMint(rpc, tokenMintA);
        fetchedMints.set(tokenMintA, mintA2.data);
      }
      if (!fetchedMints.has(tokenMintB)) {
        const mintB2 = await fetchMint(rpc, tokenMintB);
        fetchedMints.set(tokenMintB, mintB2.data);
      }
      const mintA = fetchedMints.get(tokenMintA);
      const mintB = fetchedMints.get(tokenMintB);
      const currentPrice = sqrtPriceToPrice(whirlpool.sqrtPrice, mintA.decimals, mintB.decimals);
      const positionLowerPrice = tickIndexToPrice(positionData.tickLowerIndex, mintA.decimals, mintB.decimals);
      const positionUpperPrice = tickIndexToPrice(positionData.tickUpperIndex, mintA.decimals, mintB.decimals);
      const inRange = whirlpool.tickCurrentIndex >= positionData.tickLowerIndex && whirlpool.tickCurrentIndex <= positionData.tickUpperIndex;
      const positionCenterPrice = (positionLowerPrice + positionUpperPrice) / 2;
      const distanceCenterPositionFromPoolPriceBps = Math.abs(currentPrice - positionCenterPrice) / currentPrice * 1e4;
      const positionWidthBps = (positionUpperPrice - positionLowerPrice) / positionCenterPrice * 1e4 / 2;
      return {
        whirlpoolAddress,
        positionMint,
        inRange,
        distanceCenterPositionFromPoolPriceBps,
        positionWidthBps
      };
    }));
    return FetchedPositionsStatistics;
  } catch (error) {
    elizaLogger.error("Error during feching positions:", error);
    throw new Error("Error during feching positions");
  }
};

// src/evaluators/repositionEvaluator.ts
import {
  elizaLogger as elizaLogger3
} from "@elizaos/core";

// src/actions/managePositions.ts
import {
  elizaLogger as elizaLogger2,
  parseJSONObjectFromText,
  ModelType
} from "@elizaos/core";
import { sqrtPriceToPrice as sqrtPriceToPrice2 } from "@orca-so/whirlpools-core";

// node_modules/uuid/dist/esm/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm/rng.js
import { randomFillSync } from "crypto";
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// node_modules/uuid/dist/esm/native.js
import { randomUUID } from "crypto";
var native_default = { randomUUID };

// node_modules/uuid/dist/esm/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/actions/managePositions.ts
import { createSolanaRpc as createSolanaRpc2 } from "@solana/kit";
var isManagingPositionsHandlerActive = false;
function isValidOpenPositionParams(obj) {
  if (!obj || typeof obj !== "object") return false;
  const params = obj;
  return typeof params.whirlpoolAddress === "string" && params.whirlpoolAddress.length > 0 && typeof params.lowerTick === "number" && Number.isInteger(params.lowerTick) && typeof params.upperTick === "number" && Number.isInteger(params.upperTick) && params.lowerTick < params.upperTick && // Basic sanity: lower tick must be less than upper tick
  (params.tokenAmount === void 0 || typeof params.tokenAmount === "number" && params.tokenAmount >= 0);
}
async function getInitialPositionParametersFromLLM(runtime, ownerAddress) {
  elizaLogger2.log("[GIPPL] Attempting to get initial position parameters from LLM for owner:", ownerAddress);
  const prompt = `
    You are an expert Solana DeFi assistant. A user with wallet address "${ownerAddress}" wants to open a new concentrated liquidity position on Orca.
    Please suggest parameters for an initial position. Consider common, relatively safe pairs and a reasonable starting token amount (e.g., for USDC or SOL).
    Provide the whirlpool address (as a string), lower tick (integer), upper tick (integer), and an optional token amount (number, representing the amount of one of the tokens, e.g., in its native decimal format, or a conceptual amount if the exact token isn't specified).
    If you suggest a tokenAmount, assume it's for one of the more liquid tokens in the pair (like USDC or SOL). If unsure, suggest a small tokenAmount like 10 (representing 10 units of the token).
    The lower tick must be less than the upper tick.

    Return ONLY the JSON object with the following structure. Do not include any other text, explanations, or conversational preamble.
    Ensure the tick values are integers.

    {
        "whirlpoolAddress": "string",
        "lowerTick": number,
        "upperTick": number,
        "tokenAmount": number (optional, default to 10 if not otherwise specified)
    }
  `;
  elizaLogger2.log("[GIPPL] Prompt constructed. Calling generateText.");
  let llmResponse = null;
  try {
    llmResponse = await runtime.useModel(ModelType.SMALL, { prompt });
    elizaLogger2.log(`[GIPPL] generateText call completed. Raw LLM output: ${llmResponse}`);
  } catch (modelError) {
    elizaLogger2.error("[GIPPL] Error directly from generateText call:", modelError);
    return null;
  }
  if (llmResponse === null || llmResponse.trim() === "") {
    elizaLogger2.warn("[GIPPL] LLM output is null or empty.");
    return null;
  }
  let jsonStringToParse = llmResponse;
  const jsonCodeBlockRegex = /```json\s*([\s\S]*?)\s*```/;
  const codeBlockMatch = llmResponse.match(jsonCodeBlockRegex);
  if (codeBlockMatch && codeBlockMatch[1]) {
    jsonStringToParse = codeBlockMatch[1].trim();
    elizaLogger2.log(`[GIPPL] Extracted content from json code block: ${jsonStringToParse}`);
  } else {
    const lastStartObject = llmResponse.lastIndexOf("{");
    const lastEndObject = llmResponse.lastIndexOf("}");
    if (lastStartObject !== -1 && lastEndObject !== -1 && lastEndObject > lastStartObject) {
      jsonStringToParse = llmResponse.substring(lastStartObject, lastEndObject + 1);
      elizaLogger2.log(`[GIPPL] Extracted JSON object string using lastIndexOf heuristic: ${jsonStringToParse}`);
    } else {
      elizaLogger2.warn("[GIPPL] No JSON code block found and heuristic object extraction failed.");
    }
  }
  try {
    let parsedResult = JSON.parse(jsonStringToParse);
    elizaLogger2.log("[GIPPL] Attempt 1 JSON.parse result:", parsedResult);
    if (!isValidOpenPositionParams(parsedResult)) {
      elizaLogger2.warn("[GIPPL] Parsed result from attempt 1 is not valid OpenPositionParams. Trying parseJSONObjectFromText.");
      parsedResult = parseJSONObjectFromText(llmResponse);
      elizaLogger2.log("[GIPPL] Attempt 2 parseJSONObjectFromText result:", parsedResult);
    }
    if (isValidOpenPositionParams(parsedResult)) {
      if (parsedResult.tokenAmount === void 0 || typeof parsedResult.tokenAmount !== "number" || parsedResult.tokenAmount < 0) {
        elizaLogger2.log(`[GIPPL] tokenAmount is undefined or invalid (${parsedResult.tokenAmount}), defaulting to 10.`);
        parsedResult.tokenAmount = 10;
      }
      parsedResult.lowerTick = Math.round(parsedResult.lowerTick);
      parsedResult.upperTick = Math.round(parsedResult.upperTick);
      if (parsedResult.lowerTick >= parsedResult.upperTick) {
        elizaLogger2.error(`[GIPPL] Invalid tick range after parsing/rounding: lowerTick ${parsedResult.lowerTick} >= upperTick ${parsedResult.upperTick}.`);
        return null;
      }
      elizaLogger2.log("[GIPPL] Successfully parsed and validated OpenPositionParams:", parsedResult);
      return parsedResult;
    } else {
      elizaLogger2.error("[GIPPL] Failed to parse valid OpenPositionParams from LLM response after all attempts. Parsed data:", parsedResult);
      return null;
    }
  } catch (error) {
    elizaLogger2.error("[GIPPL] Error parsing LLM response for initial position parameters:", error);
    try {
      const fallbackResult = parseJSONObjectFromText(llmResponse);
      elizaLogger2.log("[GIPPL] Fallback parseJSONObjectFromText result:", fallbackResult);
      if (isValidOpenPositionParams(fallbackResult)) {
        if (fallbackResult.tokenAmount === void 0 || typeof fallbackResult.tokenAmount !== "number" || fallbackResult.tokenAmount < 0) {
          fallbackResult.tokenAmount = 10;
        }
        fallbackResult.lowerTick = Math.round(fallbackResult.lowerTick);
        fallbackResult.upperTick = Math.round(fallbackResult.upperTick);
        if (fallbackResult.lowerTick >= fallbackResult.upperTick) {
          elizaLogger2.error(`[GIPPL] Fallback - Invalid tick range: lowerTick ${fallbackResult.lowerTick} >= upperTick ${fallbackResult.upperTick}.`);
          return null;
        }
        elizaLogger2.log("[GIPPL] Successfully parsed and validated OpenPositionParams via fallback:", fallbackResult);
        return fallbackResult;
      }
    } catch (fallbackError) {
      elizaLogger2.error("[GIPPL] Error in fallback parsing attempt:", fallbackError);
    }
    return null;
  }
}
var managePositions = {
  name: "manage_positions",
  similes: ["AUTOMATE_REBALANCING", "AUTOMATE_POSITIONS", "START_MANAGING_POSITIONS"],
  description: "Automatically manage positions by rebalancing them when they drift too far from the pool price",
  validate: async (runtime, message) => {
    if (!message || !message.content || !message.content.text || message.content.text.trim() === "") {
      elizaLogger2.warn("[Validate] Message content is missing or empty.");
      return false;
    }
    elizaLogger2.log("[Validate] Basic validation passed (message content present).");
    return true;
  },
  handler: async (runtime, message, state, params, callback) => {
    if (isManagingPositionsHandlerActive) {
      elizaLogger2.warn("managePositions handler is already active. Skipping this invocation.");
      return false;
    }
    isManagingPositionsHandlerActive = true;
    elizaLogger2.log("Start managing positions (handler activated)");
    try {
      const config = await extractAndValidateConfiguration(message.content.text, runtime);
      if (!config) {
        elizaLogger2.warn("Failed to get valid configuration for managing positions. Aborting.");
        return false;
      }
      const { address: ownerAddress } = await loadWallet(runtime, false);
      if (!ownerAddress) {
        elizaLogger2.error("Failed to load wallet address. Cannot proceed.");
        return false;
      }
      const orcaService = runtime.getService("ORCA_SERVICE");
      if (orcaService && typeof orcaService.setWallet === "function") {
        orcaService.setWallet(ownerAddress);
      }
      const rpc = createSolanaRpc2(runtime.getSetting("SOLANA_RPC_URL"));
      let positions = await orcaService.fetchPositions(ownerAddress);
      elizaLogger2.log(`Found ${positions.length} existing positions for owner ${ownerAddress}.`);
      if (positions.length === 0) {
        elizaLogger2.info("No existing positions found. Attempting to open an initial position.");
        const initialParams = await getInitialPositionParametersFromLLM(runtime, ownerAddress.toString());
        if (initialParams) {
          elizaLogger2.log("Received initial position parameters from LLM:", initialParams);
          try {
            const newPositionMint = await orcaService.open_position(initialParams);
            if (newPositionMint) {
              elizaLogger2.info(`Successfully opened initial position. Mint: ${newPositionMint}. Re-fetching positions.`);
              positions = await orcaService.fetchPositions(ownerAddress);
              elizaLogger2.log(`Found ${positions.length} positions after opening initial one.`);
            } else {
              elizaLogger2.warn("Attempted to open initial position, but open_position returned null (possibly an existing position was found by the service itself, or opening failed silently).");
            }
          } catch (openError) {
            elizaLogger2.error("Error opening initial position:", openError);
          }
        } else {
          elizaLogger2.warn("Failed to get initial position parameters from LLM. Cannot open a new position automatically.");
        }
      }
      if (positions.length === 0) {
        elizaLogger2.info("Still no positions found after attempting to open an initial one. No monitoring tasks will be created.");
        return true;
      }
      const worldId = runtime.agentId;
      for (const position of positions) {
        if (!isValidFetchedPosition(position)) {
          elizaLogger2.warn(`Skipping invalid position object: ${JSON.stringify(position)}`);
          continue;
        }
        elizaLogger2.log(`Processing position: ${position.positionMint}`);
        const positionId = await orcaService.register_position(position);
        elizaLogger2.log(`Position ${position.positionMint} registered with ID: ${positionId}. Creating monitoring task.`);
        if (!position.inRange) {
          elizaLogger2.info(`Position ${positionId} is out of range. Triggering immediate rebalance.`);
          await checkAndRebalancePosition(
            position,
            config.repositionThresholdBps,
            orcaService
          );
        }
        await runtime.createTask({
          id: v4_default(),
          name: `monitor_position_${positionId}`,
          type: "MONITOR",
          description: `Monitor and rebalance position ${positionId} (Mint: ${position.positionMint})`,
          tags: ["queue", "repeat", "position", "monitor"],
          schedule: { interval: config.intervalSeconds * 1e3 },
          worldId,
          execute: async () => {
            elizaLogger2.log(`Executing monitoring task for position ID: ${positionId}, Mint: ${position.positionMint}`);
            if (!position.inRange) {
              elizaLogger2.info(`Position ${positionId} is out of range. Triggering immediate rebalance.`);
              await checkAndRebalancePosition(
                position,
                config.repositionThresholdBps,
                orcaService
              );
            }
          }
        });
        elizaLogger2.log(`Monitoring task created for position ID: ${positionId}`);
      }
      elizaLogger2.log("Finished processing all positions and creating tasks.");
      return true;
    } catch (error) {
      elizaLogger2.error("Error in managePositions handler:", error);
      if (error instanceof Error && error.stack) {
        elizaLogger2.error("Stack trace for managePositions handler error:", error.stack);
      }
      return false;
    } finally {
      isManagingPositionsHandlerActive = false;
      elizaLogger2.log("End managing positions (handler deactivated)");
    }
  },
  examples: []
};
function isValidFetchedPosition(obj) {
  return obj && typeof obj.whirlpoolAddress === "string" && typeof obj.positionMint === "string" && typeof obj.inRange === "boolean" && typeof obj.distanceCenterPositionFromPoolPriceBps === "number" && typeof obj.positionWidthBps === "number";
}
function validateManagePositionsInput(obj) {
  if (typeof obj.repositionThresholdBps !== "number" || !Number.isInteger(obj.repositionThresholdBps) || typeof obj.intervalSeconds !== "number" || !Number.isInteger(obj.intervalSeconds) || typeof obj.slippageToleranceBps !== "number" || !Number.isInteger(obj.slippageToleranceBps)) {
    throw new Error("Invalid input: Object does not match the ManagePositionsInput type.");
  }
  return obj;
}
async function extractAndValidateConfiguration(text, runtime, position, whirlpoolData) {
  elizaLogger2.log(`[EAVC] Start. Text: "${text}"`);
  const defaultConfig = {
    repositionThresholdBps: 500,
    intervalSeconds: 300,
    slippageToleranceBps: 100
  };
  const prompt = `Given this message: "${text}". Extract or suggest the reposition threshold value, time interval, and slippage tolerance.
        The threshold value and the slippage tolerance can be given in percentages or bps. You will always respond with the reposition threshold in bps.
        ${position ? `
        Current position data:
        ${JSON.stringify(position, null, 2)}` : "\n        No position data available"}
        ${whirlpoolData ? `
        Current whirlpool data:
        ${JSON.stringify(whirlpoolData, null, 2)}` : "\n        No whirlpool data available"}
        If no values are provided in the message, suggest optimal values based on pool conditions or use these defaults: ${JSON.stringify(defaultConfig, null, 2)}.
        Very important: Add null values for each field that is not present in the message if you cannot suggest one.
        Return ONLY the JSON object with the following structure. Do not include any other text, explanations, or conversational preamble.
        {
            "repositionThresholdBps": number (integer value),
            "intervalSeconds": number (integer value),
            "slippageToleranceBps": number (integer value)
        }
    `;
  elizaLogger2.log("[EAVC] Prompt constructed. Calling generateText.");
  let json = null;
  try {
    json = await runtime.useModel(ModelType.SMALL, { prompt });
    elizaLogger2.log(`[EAVC] generateText call completed. Raw LLM output: ${json}`);
  } catch (modelError) {
    elizaLogger2.error("[EAVC] Error directly from generateText call:", modelError);
    if (modelError instanceof Error && modelError.stack) {
      elizaLogger2.error("[EAVC] generateText error stack:", modelError.stack);
    }
    return null;
  }
  if (json === null || json.trim() === "") {
    elizaLogger2.warn("[EAVC] LLM output is null or empty, cannot proceed with parsing.");
    return null;
  }
  let jsonStringToParse = json;
  const jsonCodeBlockRegex = /```json\s*([\s\S]*?)\s*```/;
  const codeBlockMatch = json.match(jsonCodeBlockRegex);
  if (codeBlockMatch && codeBlockMatch[1]) {
    jsonStringToParse = codeBlockMatch[1].trim();
    elizaLogger2.log(`[EAVC] Extracted content from json code block: ${jsonStringToParse}`);
  } else {
    elizaLogger2.log("[EAVC] No json code block found. Falling back to heuristic object extraction.");
    const lastStartObject = json.lastIndexOf("{");
    const lastEndObject = json.lastIndexOf("}");
    if (lastStartObject !== -1 && lastEndObject !== -1 && lastEndObject > lastStartObject) {
      const potentialJsonObject = json.substring(lastStartObject, lastEndObject + 1);
      if (potentialJsonObject.includes('"repositionThresholdBps"')) {
        jsonStringToParse = potentialJsonObject;
        elizaLogger2.log(`[EAVC] Extracted JSON object string using lastIndexOf heuristic: ${jsonStringToParse}`);
      } else {
        elizaLogger2.warn("[EAVC] Found last {} but keywords missing. Will attempt to parse broader content segment.");
      }
    } else {
      elizaLogger2.warn("[EAVC] Could not find clear JSON object structure using simple lastIndexOf.");
    }
  }
  let parsedLLMOutput = null;
  try {
    elizaLogger2.log("[EAVC] Attempt 1: JSON.parse on extracted string:", jsonStringToParse);
    const result = JSON.parse(jsonStringToParse);
    elizaLogger2.log("[EAVC] JSON.parse result:", result);
    if (result && typeof result === "object" && !Array.isArray(result)) {
      parsedLLMOutput = result;
    } else {
      elizaLogger2.warn("[EAVC] JSON.parse result is not a valid object. Proceeding to fallback.", result);
    }
  } catch (e) {
    elizaLogger2.warn(`[EAVC] JSON.parse failed on extracted string. Error: ${e instanceof Error ? e.message : String(e)}`);
  }
  if (!parsedLLMOutput) {
    try {
      elizaLogger2.log("[EAVC] Attempt 2: parseJSONObjectFromText on full LLM output:", json);
      const result = parseJSONObjectFromText(json);
      elizaLogger2.log("[EAVC] parseJSONObjectFromText (fallback) result:", result);
      if (result && typeof result === "object" && !Array.isArray(result)) {
        parsedLLMOutput = result;
      } else {
        elizaLogger2.warn("[EAVC] Fallback parseJSONObjectFromText result is not a valid object.", result);
      }
    } catch (coreParseError) {
      elizaLogger2.error("[EAVC] Error in fallback parseJSONObjectFromText:", coreParseError);
      if (coreParseError instanceof Error && coreParseError.stack) {
        elizaLogger2.error("[EAVC] Fallback parsing error stack:", coreParseError.stack);
      }
    }
  }
  if (!parsedLLMOutput) {
    elizaLogger2.warn("[EAVC] Failed to parse configuration from LLM after all attempts.");
    return null;
  }
  try {
    elizaLogger2.log("[EAVC] Validating and converting parsed LLM output:", parsedLLMOutput);
    const configurationWithNumbers = {};
    const keysToConvert = ["repositionThresholdBps", "intervalSeconds", "slippageToleranceBps"];
    elizaLogger2.log("[EAVC] Starting conversion loop for keys:", keysToConvert);
    for (const key of keysToConvert) {
      elizaLogger2.log(`[EAVC] Processing key: "${key}"`);
      if (Object.prototype.hasOwnProperty.call(parsedLLMOutput, key) && parsedLLMOutput[key] !== void 0 && parsedLLMOutput[key] !== null) {
        const originalValue = parsedLLMOutput[key];
        configurationWithNumbers[key] = Number(originalValue);
        elizaLogger2.log(`[EAVC] Key "${key}": Original value "${originalValue}" (type: ${typeof originalValue}), Converted value "${configurationWithNumbers[key]}" (type: ${typeof configurationWithNumbers[key]})`);
      } else {
        configurationWithNumbers[key] = parsedLLMOutput[key];
        elizaLogger2.log(`[EAVC] Key "${key}" was missing, undefined, or null in parsedLLMOutput. Assigned value: ${configurationWithNumbers[key]}`);
      }
    }
    elizaLogger2.log("[EAVC] Conversion loop finished. Resulting configurationWithNumbers:", configurationWithNumbers);
    elizaLogger2.log("[EAVC] Calling validateManagePositionsInput with:", configurationWithNumbers);
    const result = validateManagePositionsInput(configurationWithNumbers);
    elizaLogger2.log("[EAVC] validateManagePositionsInput returned successfully:", result);
    return result;
  } catch (validationOrConversionError) {
    elizaLogger2.error("[EAVC] Error during validation or conversion of LLM output:", validationOrConversionError);
    if (validationOrConversionError instanceof Error && validationOrConversionError.stack) {
      elizaLogger2.error("[EAVC] Validation/conversion error stack:", validationOrConversionError.stack);
    }
    return null;
  }
}
async function checkAndRebalancePosition(position, thresholdBps, orcaService) {
  elizaLogger2.log(`Checking position ${position.positionMint}. InRange: ${position.inRange}, DistanceBps: ${position.distanceCenterPositionFromPoolPriceBps}, ThresholdBps: ${thresholdBps}`);
  if (!position.inRange || position.distanceCenterPositionFromPoolPriceBps > thresholdBps) {
    elizaLogger2.info(`Position ${position.positionMint} needs rebalancing. InRange: ${position.inRange}, Distance: ${position.distanceCenterPositionFromPoolPriceBps} > ${thresholdBps}`);
    try {
      elizaLogger2.log(`Attempting to close position: ${position.positionMint}`);
      const closed = await orcaService.close_position(position.positionMint);
      if (!closed) {
        elizaLogger2.warn(`Failed to close position ${position.positionMint}. Aborting rebalance for this position.`);
        return;
      }
      elizaLogger2.info(`Successfully closed position ${position.positionMint}.`);
      elizaLogger2.warn(`Placeholder logic for new position parameters in checkAndRebalancePosition for whirlpool ${position.whirlpoolAddress}. This needs to be replaced with actual logic (e.g., LLM call or strategy).`);
      const newPositionParams = {
        whirlpoolAddress: position.whirlpoolAddress,
        lowerTick: 0,
        // Placeholder: Calculate based on new desired range
        upperTick: 0,
        // Placeholder: Calculate based on new desired range
        tokenAmount: 0
        // Placeholder: Determine based on closed position's value or new strategy
      };
      elizaLogger2.log(`Attempting to open new position with placeholder params:`, newPositionParams);
      const newMint = await orcaService.open_position(newPositionParams);
      if (newMint) {
        elizaLogger2.info(`Successfully opened new (rebalanced) position with mint ${newMint} for whirlpool ${position.whirlpoolAddress}. Old mint was ${position.positionMint}.`);
      } else {
        elizaLogger2.warn(`Failed to open new (rebalanced) position for whirlpool ${position.whirlpoolAddress} after closing ${position.positionMint}.`);
      }
    } catch (error) {
      elizaLogger2.error(`Rebalancing error for position ${position.positionMint}:`, error);
    }
  } else {
    elizaLogger2.log(`Position ${position.positionMint} is within range and does not need rebalancing.`);
  }
}

// src/evaluators/repositionEvaluator.ts
var managePositionActionRetriggerEvaluator = {
  name: "DEGEN_LP_REPOSITION_EVALUATOR",
  similes: ["DEGEN_LP_REPOSITION"],
  alwaysRun: true,
  description: "Schedules and monitors ongoing repositioning actions to ensure continuous operation.",
  validate: async (runtime, message) => true,
  handler: async (runtime, message, state, _options, callback) => {
    elizaLogger3.log("Checking LP position status");
    if (!state) {
      state = await runtime.composeState(message);
    } else {
      state = await runtime.composeState(message);
    }
    const config = await extractAndValidateConfiguration(message.content.text, runtime);
    if (!config || typeof config.intervalSeconds !== "number" || config.intervalSeconds <= 0) {
      elizaLogger3.debug(
        "Configuration is invalid, null, or does not have a valid positive value for intervalSeconds. Exiting evaluator."
      );
      return;
    }
    const intervalMs = config.intervalSeconds * 1e3;
    elizaLogger3.log(`Using time threshold: ${intervalMs} milliseconds`);
    await new Promise((resolve) => setTimeout(resolve, intervalMs));
    await runtime.createMemory(
      {
        content: {
          text: message.content.text
        },
        agentId: runtime.agentId,
        roomId: runtime.agentId,
        metadata: {
          type: "reposition_message"
        },
        entityId: message.id
      },
      "reposition_message"
    );
  },
  examples: []
};

// src/services/srv_orca.ts
import { Service, logger } from "@elizaos/core";
import {
  address as address2,
  createSolanaRpc as createSolanaRpc3,
  createKeyPairSignerFromBytes
} from "@solana/kit";
import { Connection, Keypair as Keypair2, PublicKey as PublicKey2 } from "@solana/web3.js";
import { PDAUtil as WhirlpoolPDAUtil } from "@orca-so/whirlpools-sdk";
import { closePositionInstructions, openPositionInstructions, decreaseLiquidityInstructions, resetPositionRangeInstructions } from "@orca-so/whirlpools";
import { fetchMaybePosition, fetchPosition, getPositionAddress } from "@orca-so/whirlpools-client";

// src/utils/sendTransaction.ts
import { elizaLogger as elizaLogger4 } from "@elizaos/core";
import {
  getSetComputeUnitLimitInstruction,
  getSetComputeUnitPriceInstruction
} from "@solana-program/compute-budget";
import {
  appendTransactionMessageInstructions,
  createTransactionMessage,
  getBase64EncodedWireTransaction,
  getComputeUnitEstimateForTransactionMessageFactory,
  pipe,
  prependTransactionMessageInstructions,
  setTransactionMessageFeePayer,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners,
  address
} from "@solana/kit";
async function sendTransaction(rpc, instructions, wallet) {
  const latestBlockHash = await rpc.getLatestBlockhash().send();
  const transactionMessage = await pipe(
    createTransactionMessage({ version: 0 }),
    (tx) => setTransactionMessageFeePayer(address(wallet.publicKey.toString()), tx),
    (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockHash.value, tx),
    (tx) => appendTransactionMessageInstructions(instructions, tx)
  );
  const getComputeUnitEstimateForTransactionMessage = getComputeUnitEstimateForTransactionMessageFactory({
    rpc
  });
  const computeUnitEstimate = await getComputeUnitEstimateForTransactionMessage(transactionMessage);
  const safeComputeUnitEstimate = Math.max(computeUnitEstimate * 1.3, computeUnitEstimate + 1e5);
  console.log("4");
  const prioritizationFee = await rpc.getRecentPrioritizationFees().send().then(
    (fees) => fees.map((fee) => Number(fee.prioritizationFee)).sort((a, b) => a - b)[Math.ceil(0.95 * fees.length) - 1]
  );
  const transactionMessageWithComputeUnitInstructions = await prependTransactionMessageInstructions([
    {
      programAddress: address("ComputeBudget111111111111111111111111111111"),
      accounts: [],
      data: getSetComputeUnitLimitInstruction({ units: safeComputeUnitEstimate }).data
    },
    {
      programAddress: address("ComputeBudget111111111111111111111111111111"),
      accounts: [],
      data: getSetComputeUnitPriceInstruction({ microLamports: prioritizationFee }).data
    }
  ], transactionMessage);
  const signedTransaction = await signTransactionMessageWithSigners(transactionMessageWithComputeUnitInstructions);
  const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);
  const timeoutMs = 9e4;
  const startTime = Date.now();
  while (Date.now() - startTime < timeoutMs) {
    const transactionStartTime = Date.now();
    const signature = await rpc.sendTransaction(base64EncodedWireTransaction, {
      maxRetries: 0n,
      skipPreflight: true,
      encoding: "base64"
    }).send();
    const statuses = await rpc.getSignatureStatuses([signature]).send();
    if (statuses.value[0]) {
      if (!statuses.value[0].err) {
        elizaLogger4.log(`Transaction confirmed: ${signature}`);
        return signature;
      } else {
        throw new Error(`Transaction failed: ${statuses.value[0].err.toString()}`);
      }
    }
    const elapsedTime = Date.now() - transactionStartTime;
    const remainingTime = Math.max(0, 1e3 - elapsedTime);
    if (remainingTime > 0) {
      await new Promise((resolve) => setTimeout(resolve, remainingTime));
    }
  }
  throw new Error("Transaction timeout");
}

// src/services/srv_orca.ts
var import_bn = __toESM(require_bn(), 1);
import { fetchPositionsForOwner as fetchPositionsForOwner2, setDefaultFunder } from "@orca-so/whirlpools";
import { fetchWhirlpool as fetchWhirlpool2 } from "@orca-so/whirlpools-client";
import { fetchAllMint, fetchMint as fetchMint2 } from "@solana-program/token-2022";
import { sqrtPriceToPrice as sqrtPriceToPrice3, tickIndexToPrice as tickIndexToPrice2, priceToTickIndex, getInitializableTickIndex } from "@orca-so/whirlpools-core";
import bs582 from "bs58";
var MAINNET_WHIRLPOOLS_CONFIG_PUBKEY = new PublicKey2("2LecshUwdy9xi7meFgHtFJQNSKk4KdTrcpvaB56dP2NQ");
var MAINNET_WHIRLPOOL_PROGRAM_ID = new PublicKey2("whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3dhpGDH");
var COMMON_QUOTE_TOKENS_MINTS = [
  "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  // USDC
  "So11111111111111111111111111111111111111112",
  // WSOL
  "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"
  // USDT
];
var TICK_SPACINGS_TO_CHECK = [1, 8, 64, 128];
var OrcaService = class _OrcaService extends Service {
  connection;
  rpc;
  wallet;
  isRunning = false;
  registeredPositions = /* @__PURE__ */ new Map();
  // For register_position
  static serviceType = "ORCA_SERVICE";
  capabilityDescription = "Provides Orca DEX integration and position management";
  constructor(runtime) {
    super(runtime);
    this.connection = new Connection(runtime.getSetting("SOLANA_RPC_URL"));
    this.rpc = createSolanaRpc3(runtime.getSetting("SOLANA_RPC_URL"));
    const privateKeyString = runtime.getSetting("SOLANA_PRIVATE_KEY");
    if (!privateKeyString) {
      throw new Error("SOLANA_PRIVATE_KEY not found in settings");
    }
    const privateKeyBytes = bs582.decode(privateKeyString);
    this.wallet = Keypair2.fromSecretKey(privateKeyBytes);
    createKeyPairSignerFromBytes(privateKeyBytes).then((signer) => {
      this.signer = signer;
      console.log("this.signer", this.signer);
    });
    logger.debug("ORCA_SERVICE: Wallet initialized");
    console.log("ORCA_SERVICE cstr");
  }
  static async start(runtime) {
    console.log("ORCA_SERVICE trying to start");
    return new _OrcaService(runtime);
  }
  async start() {
    console.log("ORCA_SERVICE trying to start");
  }
  async stop() {
    console.log("ORCA_SERVICE trying to stop");
  }
  getWalletKeypair() {
    try {
      const privateKeyString = this.runtime.getSetting("SOLANA_PRIVATE_KEY");
      if (!privateKeyString) {
        logger.error("Private key not found in settings");
        throw new Error("Private key not found");
      }
      const privateKeyBytes = bs582.decode(privateKeyString);
      return Keypair2.fromSecretKey(privateKeyBytes);
    } catch (error) {
      logger.error("Failed to create keypair:", error);
      throw error;
    }
  }
  async register_position(position) {
    logger.debug("=== Registering Position ===");
    logger.debug("Position details:", {
      mint: position.positionMint,
      whirlpool: position.whirlpoolAddress,
      inRange: position.inRange,
      distanceFromCenter: position.distanceCenterPositionFromPoolPriceBps,
      width: position.positionWidthBps
    });
    this.registeredPositions.set(position.positionMint, position);
    logger.debug(
      "Current registered positions:",
      Array.from(this.registeredPositions.entries()).map(([key, pos]) => ({
        mint: key,
        whirlpool: pos.whirlpoolAddress,
        inRange: pos.inRange
      }))
    );
    return position.positionMint;
  }
  setupFeeCollection() {
    try {
      if (!this.wallet) {
        logger.error("Cannot setup fee collection - wallet not initialized");
        return false;
      }
      const feeCollector = this.wallet.publicKey.toBase58();
      const feeParams = {
        whirlpoolsConfig: feeCollector,
        defaultBaseFeeRate: 100,
        // 1% fee
        feeAuthority: {
          address: this.wallet.publicKey.toBase58(),
          signTransactions: async (txs) => {
            const signatures = await Promise.all(txs.map((tx) => {
              const signature = this.wallet.secretKey.slice(0, 64);
              return { [this.wallet.publicKey.toBase58()]: signature };
            }));
            return signatures;
          }
        },
        adaptiveFeeTier: feeCollector
      };
      logger.debug("Setting up fee collection:", {
        collector: feeCollector,
        params: feeParams
      });
      return true;
    } catch (error) {
      logger.error("Error setting up fee collection:", error);
      return false;
    }
  }
  async close_position(positionId) {
    try {
      logger.debug(`OrcaService: close_position called for ID ${positionId}`);
      setDefaultFunder(this.signer);
      const positionMintAddress = address2(positionId);
      logger.info(`Attempting to close position: Mint ${positionId}`);
      const [positionAddress] = await getPositionAddress(positionMintAddress);
      const position = await fetchMaybePosition(this.rpc, positionAddress);
      if (!position.exists) {
        logger.error(`Position ${positionId} not found`);
        return false;
      }
      const { instructions, quote, feesQuote } = await closePositionInstructions(
        this.rpc,
        positionMintAddress
      );
      if (!instructions || instructions.length === 0) {
        logger.error("No instructions generated for closing position");
        return false;
      }
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      const txId = await sendTransaction(this.rpc, instructions, this.wallet);
      logger.info(`Position close transaction sent: ${txId}`);
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      const positionAfter = await fetchMaybePosition(this.rpc, positionAddress);
      if (positionAfter.exists) {
        throw new Error("Position was not closed successfully");
      }
      logger.info(`Position closed successfully. Tokens returned: A=${quote.tokenEstA + feesQuote.feeOwedA}, B=${quote.tokenEstB + feesQuote.feeOwedB}`);
      logger.info(`OrcaService: Successfully closed position ${positionId} on-chain. Transaction ID: ${txId}`);
      this.registeredPositions.delete(positionId);
      logger.info(`OrcaService: Position ${positionId} unregistered locally.`);
      return true;
    } catch (error) {
      logger.error("Error in close_position:", error);
      return false;
    }
  }
  async open_position(params) {
    logger.info("OrcaService: open_position called.");
    logger.debug("Attempting to open position with params:", params);
    try {
      const whirlpool = await fetchWhirlpool2(
        this.rpc,
        params.whirlpoolAddress
      );
      if (!whirlpool) {
        throw new Error("Whirlpool not found");
      }
      setDefaultFunder(this.signer);
      const mintA = await fetchMint2(this.rpc, whirlpool.data.tokenMintA);
      const mintB = await fetchMint2(this.rpc, whirlpool.data.tokenMintB);
      const lowerTickIndex = priceToTickIndex(
        params.lowerTick,
        mintA.data.decimals,
        mintB.data.decimals
      );
      const upperTickIndex = priceToTickIndex(
        params.upperTick,
        mintA.data.decimals,
        mintB.data.decimals
      );
      const initializableLowerTick = getInitializableTickIndex(
        lowerTickIndex,
        whirlpool.data.tickSpacing,
        false
      );
      const initializableUpperTick = getInitializableTickIndex(
        upperTickIndex,
        whirlpool.data.tickSpacing,
        true
      );
      const { instructions, positionMint } = await openPositionInstructions(
        this.rpc,
        params.whirlpoolAddress,
        {
          liquidity: BigInt(1e9)
        },
        initializableLowerTick,
        initializableUpperTick
      );
      const txId = await sendTransaction(this.rpc, instructions, this.wallet);
      logger.info(`Position opened successfully. TX: ${txId}, Position Mint: ${positionMint}`);
      const [positionAddress] = await getPositionAddress(positionMint);
      const position = await fetchMaybePosition(this.rpc, positionAddress);
      if (!position.exists) {
        throw new Error("Position was not created successfully");
      }
      return positionMint.toString();
    } catch (error) {
      logger.error("Error in open_position:", error);
      throw error;
    }
  }
  async fetchPositions(ownerAddress) {
    try {
      logger.debug("=== Starting fetchPositions ===");
      logger.debug("Owner address:", ownerAddress);
      const ownerAddressString = ownerAddress.toString();
      logger.debug("Owner address as string:", ownerAddressString);
      const jsonReplacer = (key, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
      const positions = await fetchPositionsForOwner2(this.rpc, ownerAddressString);
      logger.debug("Raw positions fetched:", JSON.stringify(positions, jsonReplacer, 2));
      if (!positions || positions.length === 0) {
        logger.debug("No positions found for owner");
        return [];
      }
      const fetchedWhirlpools = /* @__PURE__ */ new Map();
      const fetchedMints = /* @__PURE__ */ new Map();
      const FetchedPositionsStatistics = await Promise.all(
        positions.map(async (position) => {
          const positionData = position.data;
          logger.debug("Processing position:", {
            positionMint: positionData.positionMint,
            whirlpool: positionData.whirlpool
          });
          const positionMint = positionData.positionMint;
          const whirlpoolAddress = positionData.whirlpool;
          if (!fetchedWhirlpools.has(whirlpoolAddress)) {
            logger.debug("Fetching new whirlpool:", whirlpoolAddress);
            const whirlpool2 = await fetchWhirlpool2(this.rpc, whirlpoolAddress);
            if (whirlpool2) {
              fetchedWhirlpools.set(whirlpoolAddress, whirlpool2.data);
              logger.debug("Whirlpool fetched and cached");
            }
          }
          const whirlpool = fetchedWhirlpools.get(whirlpoolAddress);
          logger.debug("Whirlpool data:", {
            tokenMintA: whirlpool.tokenMintA,
            tokenMintB: whirlpool.tokenMintB,
            tickCurrentIndex: whirlpool.tickCurrentIndex
          });
          const { tokenMintA, tokenMintB } = whirlpool;
          if (!fetchedMints.has(tokenMintA)) {
            const mintA2 = await fetchMint2(this.rpc, tokenMintA);
            fetchedMints.set(tokenMintA, mintA2.data);
          }
          if (!fetchedMints.has(tokenMintB)) {
            const mintB2 = await fetchMint2(this.rpc, tokenMintB);
            fetchedMints.set(tokenMintB, mintB2.data);
          }
          const mintA = fetchedMints.get(tokenMintA);
          const mintB = fetchedMints.get(tokenMintB);
          const currentPrice = sqrtPriceToPrice3(whirlpool.sqrtPrice, mintA.decimals, mintB.decimals);
          const positionLowerPrice = tickIndexToPrice2(positionData.tickLowerIndex, mintA.decimals, mintB.decimals);
          const positionUpperPrice = tickIndexToPrice2(positionData.tickUpperIndex, mintA.decimals, mintB.decimals);
          const inRange = whirlpool.tickCurrentIndex >= positionData.tickLowerIndex && whirlpool.tickCurrentIndex <= positionData.tickUpperIndex;
          const positionCenterPrice = (positionLowerPrice + positionUpperPrice) / 2;
          const distanceCenterPositionFromPoolPriceBps = Math.abs(currentPrice - positionCenterPrice) / currentPrice * 1e4;
          const positionWidthBps = (positionUpperPrice - positionLowerPrice) / positionCenterPrice * 1e4 / 2;
          const result = {
            whirlpoolAddress: whirlpoolAddress.toString(),
            positionMint: positionMint.toString(),
            inRange,
            distanceCenterPositionFromPoolPriceBps,
            positionWidthBps
          };
          logger.debug("Processed position result:", result);
          return result;
        })
      );
      logger.debug("=== Final results ===");
      logger.debug("Total positions processed:", FetchedPositionsStatistics.length);
      logger.debug("Positions:", JSON.stringify(FetchedPositionsStatistics, jsonReplacer, 2));
      return FetchedPositionsStatistics;
    } catch (error) {
      logger.error("Error fetching positions:", error);
      logger.error("Error stack:", error.stack);
      throw new Error("Error fetching positions");
    }
  }
  async best_lp(inputTokenMintStr, amount) {
    let bestPoolFound = null;
    let maxLiquidity = new import_bn.default(0);
    const positions = await this.fetchPositions(this.wallet.publicKey.toBase58());
    for (const position of positions) {
      const whirlpool = await fetchWhirlpool2(this.rpc, position.whirlpoolAddress);
      if (whirlpool && (whirlpool.data.tokenMintA === inputTokenMintStr || whirlpool.data.tokenMintB === inputTokenMintStr)) {
        const result = {
          address: position.whirlpoolAddress,
          liquidity: whirlpool.data.liquidity.toString(),
          tokenAMint: whirlpool.data.tokenMintA,
          tokenBMint: whirlpool.data.tokenMintB,
          tickSpacing: whirlpool.data.tickSpacing,
          rawData: whirlpool.data
        };
        logger.info(`Found existing pool: ${result.address} (${result.tokenAMint}-${result.tokenBMint}) with liquidity ${result.liquidity}`);
        return result;
      }
    }
    logger.debug(`OrcaService: Searching for new pools for token ${inputTokenMintStr}`);
    for (const quoteTokenMintStr of COMMON_QUOTE_TOKENS_MINTS) {
      if (inputTokenMintStr === quoteTokenMintStr) continue;
      for (const tickSpacing of TICK_SPACINGS_TO_CHECK) {
        try {
          const whirlpoolPda = WhirlpoolPDAUtil.getWhirlpool(
            MAINNET_WHIRLPOOL_PROGRAM_ID,
            MAINNET_WHIRLPOOLS_CONFIG_PUBKEY,
            new PublicKey2(inputTokenMintStr),
            new PublicKey2(quoteTokenMintStr),
            tickSpacing
          );
          const whirlpool = await fetchWhirlpool2(this.rpc, whirlpoolPda.publicKey.toBase58());
          if (whirlpool) {
            const currentLiquidity = new import_bn.default(whirlpool.data.liquidity);
            if (currentLiquidity.gt(maxLiquidity)) {
              maxLiquidity = currentLiquidity;
              bestPoolFound = {
                address: whirlpoolPda.publicKey.toBase58(),
                liquidity: currentLiquidity.toString(),
                tokenAMint: whirlpool.data.tokenMintA,
                tokenBMint: whirlpool.data.tokenMintB,
                tickSpacing: whirlpool.data.tickSpacing,
                rawData: whirlpool.data
              };
            }
          }
        } catch (error) {
          logger.debug(`Pool not found for ${inputTokenMintStr}-${quoteTokenMintStr} with tick spacing ${tickSpacing}`);
        }
      }
    }
    if (bestPoolFound) {
      logger.info(`Found best new pool: ${bestPoolFound.address} with liquidity ${bestPoolFound.liquidity}`);
    } else {
      logger.info(`No suitable pools found for token ${inputTokenMintStr}`);
    }
    return bestPoolFound;
  }
  async reset_position(positionId, newLowerPrice, newUpperPrice) {
    try {
      logger.info("OrcaService: reset_position called.");
      logger.debug(`Attempting to reset position ${positionId} to price range: ${newLowerPrice}-${newUpperPrice}`);
      setDefaultFunder(this.signer);
      const positionMintAddress = address2(positionId);
      const [positionAddress] = await getPositionAddress(positionMintAddress);
      const position = await fetchPosition(this.rpc, positionAddress);
      if (!position) {
        logger.error(`Position ${positionId} not found`);
        return false;
      }
      const { instructions: decreaseInstructions } = await decreaseLiquidityInstructions(
        this.rpc,
        positionMintAddress,
        {
          liquidity: position.data.liquidity
        }
      );
      const decreaseTxId = await sendTransaction(this.rpc, decreaseInstructions, this.wallet);
      logger.info(`Decreased liquidity to 0. TX: ${decreaseTxId}`);
      const { instructions: resetInstructions } = await resetPositionRangeInstructions(
        this.rpc,
        positionMintAddress,
        newLowerPrice,
        newUpperPrice,
        this.signer
      );
      const resetTxId = await sendTransaction(this.rpc, resetInstructions, this.wallet);
      logger.info(`Reset position range. TX: ${resetTxId}`);
      const positionAfter = await fetchPosition(this.rpc, positionAddress);
      const whirlpool = await fetchWhirlpool2(this.rpc, positionAfter.data.whirlpool);
      const [mintA, mintB] = await fetchAllMint(this.rpc, [
        whirlpool.data.tokenMintA,
        whirlpool.data.tokenMintB
      ]);
      const lowerTickIndex = priceToTickIndex(
        newLowerPrice,
        mintA.data.decimals,
        mintB.data.decimals
      );
      const upperTickIndex = priceToTickIndex(
        newUpperPrice,
        mintA.data.decimals,
        mintB.data.decimals
      );
      const initializableLowerTick = getInitializableTickIndex(
        lowerTickIndex,
        whirlpool.data.tickSpacing,
        false
      );
      const initializableUpperTick = getInitializableTickIndex(
        upperTickIndex,
        whirlpool.data.tickSpacing,
        true
      );
      if (positionAfter.data.tickLowerIndex !== initializableLowerTick || positionAfter.data.tickUpperIndex !== initializableUpperTick) {
        throw new Error("Position was not reset to correct tick range");
      }
      logger.info(`Successfully reset position ${positionId} to new price range`);
      return true;
    } catch (error) {
      logger.error("Error in reset_position:", error);
      return false;
    }
  }
};

// src/index.ts
var orcaPlugin = {
  name: "Orca LP Plugin",
  description: "Orca LP plugin",
  evaluators: [managePositionActionRetriggerEvaluator],
  providers: [positionProvider],
  actions: [managePositions],
  services: [OrcaService],
  init: async (_, runtime) => {
    console.log("orca init");
    new Promise(async (resolve) => {
      resolve();
      const asking = "orca";
      let serviceType = "chain_solana";
      let traderChainService = runtime.getService(serviceType);
      while (!traderChainService) {
        console.log(asking, "waiting for", serviceType, "service...");
        traderChainService = runtime.getService(serviceType);
        if (!traderChainService) {
          await new Promise((waitResolve) => setTimeout(waitResolve, 1e3));
        } else {
          console.log(asking, "Acquired", serviceType, "service...");
        }
      }
      const me = {
        name: "Orca services"
      };
      traderChainService.registerExchange(me);
      serviceType = "TRADER_LIQUIDITYPOOL";
      let traderLpService = runtime.getService(serviceType);
      while (!traderLpService) {
        console.log(asking, "waiting for", serviceType, "service...");
        traderLpService = runtime.getService(serviceType);
        if (!traderLpService) {
          await new Promise((waitResolve) => setTimeout(waitResolve, 1e3));
        } else {
          console.log(asking, "Acquired", serviceType, "service...");
        }
      }
      const tasks = await runtime.getTasks({
        tags: ["queue", "repeat", "orca"]
      });
      for (const task of tasks) {
        await runtime.deleteTask(task.id);
      }
      const worldId = runtime.agentId;
      runtime.registerTaskWorker({
        name: "ORCA_BALANCE",
        validate: async (_runtime, _message, _state) => {
          return true;
        },
        execute: async (runtime2, _options, task) => {
          const memory = {
            entityId: worldId,
            roomId: worldId,
            content: {
              text: ""
            }
          };
          const state = await runtime2.composeState(memory);
          managePositions.handler(runtime2, memory, state);
        }
      });
      runtime.createTask({
        name: "ORCA_BALANCE",
        description: "Balance orca pools",
        worldId,
        metadata: {
          createdAt: Date.now(),
          updatedAt: Date.now(),
          updateInterval: 1e3 * 60 * 5
          // 5 minutes
        },
        tags: ["queue", "repeat", "orca", "immediate"]
      });
      console.log("orca init done");
    });
  }
};
var index_default = orcaPlugin;
export {
  index_default as default,
  orcaPlugin
};
//# sourceMappingURL=index.js.map